
# 객체

<info:types> 챕터에서 배웠듯이 자바스크립트엔 일곱 가지 자료형이 있습니다. 이 중 여섯 개는 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있어 "원시형(primitive type)"이라 부릅니다.

그런데 객체형은 원시형과 달리 다양한 데이터를 담을 수 있습니다. 키로 구분된 데이터 집합이나 복잡한 개체(entity)를 저장할 수 있죠. 객체는 자바스크립트 거의 모든 면에 녹아있는 개념이므로 자바스크립트를 잘 다루려면 객체를 잘 이해하고 있어야 합니다.

객체는 중괄호 `{…}`를 이용해 만들 수 있습니다. 중괄호 안에는 "키(key): 값(value)" 쌍으로 구성된 *프로퍼티(property)* 를 여러 개 넣을 수 있는데, `키`("프로퍼티 이름"이라고도 부름)엔 문자형, `값`엔 모든 자료형이 허용됩니다.

서랍장을 상상하면 객체를 이해하기 쉽습니다. 서랍장 안 파일은 프로퍼티, 파일 각각에 붙어있는 이름표는 객체의 키라고 생각하시면 됩니다. 복잡한 서랍장 안에서 이름표를 보고 원하는 파일을 쉽게 찾을 수 있듯이, 객체에선 키를 이용해 프로퍼티를 쉽게 찾을 수 있습니다. 추가나 삭제도 마찬가지입니다.

![](object.svg)

빈 객체("빈 서랍장")를 만드는 방법은 두 가지가 있습니다.

```js
let user = new Object(); // "객체 생성자" 문법
let user = {};  // "객체 리터럴" 문법
```

![](object-user-empty.svg)

중괄호 `{...}`를 이용해 객체를 만드는 방식을 *객체 리터럴(object literal)* 이라고 부릅니다.

## 리터럴과 프로퍼티

대괄호 `{...}` 안에는 "키: 값" 쌍으로 구성된 프로퍼티가 들어갑니다.

```js
let user = {     // 객체
  name: "John",  // 키: "name",  값: "John"
  age: 30        // 키: "age", 값: 30
};
```

`"콜론(:)"`을 기준으로 왼쪽엔 키("이름" 또는 "식별자"라고도 부름)가, 오른쪽엔 값이 위치합니다.

객체 `user`에는 프로퍼티가 두 개 있습니다.

1. 첫 번째 프로퍼티 -- `"name"`(이름)과 `"John"`(값)
2. 두 번째 프로퍼티 -- `"age"`(이름)과 `30`(값)

서랍장(객체 `user`) 안에 파일 두 개(프로퍼티 두 개)가 담겨있는데, 각 파일에 "name", "age"라는 이름표가 붙어있다고 생각하시면 쉽습니다.

![user object](object-user.svg)

서랍장에 파일을 추가하고 뺄 수 있듯이 개발자는 프로퍼티를 추가, 삭제할 수 있습니다.

점 표기법(dot notation)을 이용하면 프로퍼티 값을 읽는 것도 가능합니다.

```js
// 프로퍼티 값 얻기
alert( user.name ); // John
alert( user.age ); // 30
```

프로퍼티 값엔 모든 자료형이 올 수 있습니다. 불린형 프로퍼티를 추가해보겠습니다.

```js
user.isAdmin = true;
```

![user object 2](object-user-isadmin.svg)

`delete` 연산자를 사용하면 프로퍼티를 삭제할 수 있습니다.

```js
delete user.age;
```

![user object 3](object-user-delete.svg)

프로퍼티 이름을 여러 단어를 조합해 만들었다면, 프로퍼티 이름을 따옴표로 묶어줘야 합니다.

```js
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // 복수의 단어는 따옴표로 묶어야 합니다.
};
```

![](object-user-props.svg)


마지막 프로퍼티 끝에 쉼표를 붙여도 괜찮습니다.
```js
let user = {
  name: "John",
  age: 30*!*,*/!*
}
```
이런 쉼표를 "trailing(길게 늘어지는)" 혹은 "hanging(매달리는)" 쉼표라고 부릅니다. 마지막 프로퍼티 끝에 쉼표를 붙여주면 모든 프로퍼티가 유사한 형태를 보이기 때문에 프로퍼티를 추가, 삭제, 이동하는 게 쉬워집니다.

## 대괄호 표기법

여러 단어를 조합해 프로퍼티 키를 만든 경우엔 점 표기법을 사용해 프로퍼티 값을 읽을 수 없습니다.

```js run
// 문법 에러 발생(Error: Unexpected identifier)
user.likes birds = true
```

점 표기법은 키가 유효한 변수 식별자인 경우에만 사용할 수 있습니다.(유효한 변수 식별자가 되려면 공백이 있으면 안 됩니다.)

키가 유효한 변수 식별자가 아닌 경우엔 "대괄호 표기법(square bracket notation)"이라 불리는 방법을 점 표기법 대신에 사용할 수 있습니다. 대괄호 표기법은 키에 어떤 문자열이 있던지 상관없이 동작합니다.

```js run
let user = {};

// set
user["likes birds"] = true;

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];
```

이제 문법 에러가 발행하지 않네요. 대괄호 표기법을 사용할 땐 대괄호 안 문자열을 따옴표로 묶어줘야 한다는 점에 주의하시기 바랍니다. 따옴표의 종류(큰따옴표, 작은따옴표)는 상관없습니다.

대괄호 표기법을 사용하면 문자열뿐만 아니라 모든 표현식의 평가 결과를 프로퍼티 키로 사용할 수 있습니다. 아래 예시에선 변수를 키로 사용하고 있습니다.

```js
let key = "likes birds";

// user["likes birds"] = true; 와 같습니다.
user[key] = true;
```

변수 `key`는 런타임에 평가되거나 사용자 입력에 따라 그 값이 변경될 수 있습니다. 어떤 경우든 평가가 끝난 이후 그 결과가 프로퍼티 키로 사용됩니다. 이를 응용하면 코드를 유연하게 작성할 수 있습니다.

예시:

```js run
let user = {
  name: "John",
  age: 30
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

// 변수로 접근
alert( user[key] ); // John ("name"을 입력한 경우)
```

그런데 점 표기법은 위와 같은 방식으로 사용할 수 없습니다.

```js run
let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
```

### 계산된 프로퍼티

객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여 있다면, 이를 *계산된 프로퍼티(computed property)* 라고 부릅니다.

예시:

```js run
let fruit = prompt("어떤 과일을 찾고계시나요?", "apple");

let bag = {
*!*
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
*/!*
};

alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
```

위 예시에서 `[fruit]`은 프로퍼티 이름을 변수 `fruit`에서 가져오겠다는 것을 의미합니다. 어렵지 않으시죠?

사용자가 프롬프트 대화상자에 `"apple"`을 입력했다면 `bag`엔 `{apple: 5}`가 할당되었을 겁니다.

아래 예시는 위 예시와 동일하게 동작합니다.
```js run
let fruit = prompt("Which fruit to buy?", "apple");
let bag = {};

// 변수 fruit을 사용해 프로퍼티 이름을 만들었습니다.
bag[fruit] = 5;
```

두 방식 중 객체 리터럴 안에 직접 대괄호를 사용한 방식(계산된 프로퍼티를 사용한 예시)이 더 깔끔해 보이네요.

아래와 같이 대괄호 안에 복잡한 표현식을 사용하는 것도 가능합니다.

```js
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

대괄호 표기법은 프로퍼티 이름과 값의 제약을 없애주기 때문에 점 표기법보다 훨씬 강력합니다. 그런데 작성하기 번거롭다는 단점이 있습니다.

이런 이유로 (프로퍼티 이름이 확정된 상황이고, 이름도 단순하다면) 처음엔 점 표기법을 사용하다가 뭔가 복잡한 상황이 발생했을 때 대괄호 표기법으로 바꾸는 경우가 많습니다.



````smart header="예약어도 프로퍼티 이름으로 사용할 수 있습니다."
"for", "let", "return" 같은 예약어는 변수명으로 사용할 수 없습니다.

하지만 객체 프로퍼티엔 이런 제약이 없습니다. 자바스크립트 예약어도 프로퍼티 키로 사용할 수 있죠.

```js run
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
```

기본적으로 객체 이름에 제약을 두진 않지만, 역사적인 이유 때문에 특별 대우를 받는 이름이 하나 있습니다. 바로, `"__proto__"`입니다. 프로퍼티 이름(키)이 `"__proto__"`인 경우엔 값에 객체만 올 수 있습니다. 객체 이외의 자료는 프로퍼티 값으로 설정할 수 없습니다.

```js run
let obj = {};
obj.__proto__ = 5;
alert(obj.__proto__); // 5 대신 [object Object]가 출력됩니다.
```

예시에서 확인했듯이, 원시자료 `5`를 할당하면 객체가 아니기 때문에 무시됩니다.

만약 우리가 임의의 키-값 쌍을 객체에 저장하고, 방문자가 키를 지정할 수 있게 한다면 이런 특별 대우는 버그와 취약성의 원인이 될 수 있습니다.

방문자가 __proto__를 키로 사용하면, 위 예시에서와같이 할당 연산이 무시될 가능성이 있기 때문입니다.

지금은 객체에 대해 더 많이 공부해야 하므로, 객체가 `__proto__`를 일반 프로퍼티처럼 취급할 수 있게 하는 방법은 나중에 다루도록 하겠습니다.

[Map](info:map-set)이라는 자료구조를 사용하면 임의의 키를 지정할 수 있습니다. 자세한 내용은 <info:map-set> 챕터에서 다루도록 하겠습니다.
````


## 단축 프로퍼티

실제 코드에선 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 많습니다.

예시:

```js run
function makeUser(name, age) {
  return {
    name: name,
    age: age
    // ...등등
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
```

프로퍼티 이름과 값이 같을 땐, *단축 프로퍼티(property shorthand)* 를 사용해 편리하게 프로퍼티를 설정할 수 있습니다.

위 예시에서 `name:name` 대신 `name`만 적어주어도 프로퍼티를 설정할 수 있죠.

```js
function makeUser(name, age) {
*!*
  return {
    name, // name: name 과 같음
    age   // age: age 와 같음
    // ...
  };
*/!*
}
```

한 객체에서 일반 프로퍼티와 단축 프로퍼티를 함께 사용하는 것도 가능합니다.

```js
let user = {
  name,  // name: name 과 같음
  age: 30
};
```

## 프로퍼티 존재 여부 확인하기

객체의 중요한 특징 중 하나는 존재하지 않는 프로퍼티에 접근하려 해도 에러가 발생하지 않고 `undefined`를 반환한다는 것입니다. 이런 특징을 응용하면 프로퍼티 존재 여부를 확인할 수 있습니다. 

```js run
let user = {};

alert( user.noSuchProperty === undefined ); // true는 "프로퍼티가 존재하지 않음"을 의미합니다.
```

연산자 `"in"`을 사용해 프로퍼티 존재 여부를 확인할 수도 있습니다.

문법은 다음과 같습니다.
```js
"key" in object
```

예시:

```js run
let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```

`in` 왼쪽엔 반드시 *프로퍼티 이름*이 와야 합니다. 프로퍼티 이름은 보통 따옴표로 감싼 문자열입니다.

따옴표를 생략하면 아래 예시와 같이 엉뚱한 변수가 조사 대상이 됩니다. 

```js run
let user = { age: 30 };

let key = "age";
alert( *!*key*/!* in user ); // true, 변수 key에 저장된 값("age")을 사용해 프로퍼티 존재 여부를 확인합니다.
```

````smart header="값이 `undefined`인 프로퍼티에 \"in\" 사용하기"
일치 연산자를 사용해서 프로퍼티 존재 여부를 알아내는 방법(`"=== undefined"`)은 꽤 잘 동작합니다. 이 방법이 실패할 때도 가끔 있는데, 그럴 때는 `"in"`을 사용하면 프로퍼티 존재 여부를 제대로 판별할 수 있습니다.

프로퍼티는 존재하는데, 값에 `undefined`를 할당한 예시를 살펴봅시다.

```js run
let obj = {
  test: undefined
};

alert( obj.test ); // 값이 `undefined`이므로, 얼럿창엔 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재합니다.

alert( "test" in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있습니다(true가 출력됨).
```


`obj.test`는 실제 존재하는 프로퍼티입니다. 따라서 `in` 연산자는 정상적으로 true를 반환합니다.

위 예시같이 프로퍼티 값이 `undefined`인 경우는 흔치 않습니다.`undefined`는 변수는 정의되어 있으나 값이 할당되지 않은 경우에 쓰이죠. 값을 "알 수 없거나(unknown)" 값이 "비어 있다는(empty)" 것을 나타내려면 주로 `null`을 사용합니다. 위 예시에서 `in` 연산자는 자리에 어울리지 않는 초대손님처럼 보입니다.
````

## "for..in" 반복문

`for..in` 반복문을 사용하면 객체의 모든 키를 순회할 수 있습니다. `for..in`은 앞서 학습했던 `for(;;)` 반복문과는 완전히 다릅니다.

문법:

```js
for (key in object) {
  // 각 프로퍼티 키(key)를 이용하여 본문(body)을 실행합니다.
}
```

아래 예시는 객체 `user`의 모든 프로퍼티를 출력해줍니다.

```js run
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // 키
  alert( key );  // name, age, isAdmin
  // 키에 해당하는 값
  alert( user[key] ); // John, 30, true
}
```

`for..in` 반복문에서도 `for(;;)`문처럼 반복 변수(looping variable)를 선언했다는 점에 주목해 주시기 바랍니다.

변수명(`let key`)은 자유롭게 정할 수 있습니다. `"for (let prop in obj)"`같이 `key` 말고 다른 변수명을 사용해도 괜찮습니다.


### 객체 정렬 방식

객체와 객체 프로퍼티를 다루다 보면 다음과 같은 의문이 생깁니다. '객체 프로퍼티엔 순서가 있을까?', '반복문은 프로퍼티를 추가한 순서대로 수행될까?', '프로퍼티 순서는 변하지 않을까?'와 같은 의문 말이죠.

객체는 "특별한 기준으로 정렬됩니다". 정수 프로퍼티(키가 정수)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬됩니다. 자세한 내용은 예제를 통해 살펴봅시다.

아래 객체엔 국제전화 나라 번호가 담겨있습니다.

```js run
let codes = {
  "49": "독일",
  "41": "스위스",
  "44": "영국",
  // ..,
  "1": "미국"
};

*!*
for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
*/!*
```

현재 개발 중인 애플리케이션의 주 사용자가 독일인이라고 가정해 봅시다. 나라 번호를 선택하는 화면에서 `49`가 맨 앞에 오도록 하는 게 좋겠죠? 

그런데 코드를 실행해 보면 예상과는 전혀 다른 결과가 출력됩니다.

- 미국(1)이 첫 번째로 출력됩니다.
- 그 뒤로 스위스(41)가 출력되고 나머지가 뒤따릅니다.

예상치 못한 결과가 나타난 이유는 나라 번호(키)가 정수이어서 `1, 41, 44, 49` 순으로 프로퍼티가 자동 정렬되었기 때문입니다. 

````smart header="정수 프로퍼티? 그게 뭔가요?"
"정수 프로퍼티(integer property)"는 변형 없이 정수에서 왔다 갔다 할 수 있는 문자열을 의미합니다.

"49"는 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 변형이 없기 때문에 정수 프로퍼티입니다. 하지만 "+49"와 "1.2"는 정수 프로퍼티가 될 수 없습니다.

```js run
// 함수 Math.trunc는 소수점 아래를 버리고 숫자의 정수부만 반환합니다.
alert( String(Math.trunc(Number("49"))) ); // "49"가 출력됩니다. 기존에 입력한 값과 같으므로 정수 프로퍼티가 될 수 있습니다.
alert( String(Math.trunc(Number("+49"))) ); // "49"가 출력됩니다. 기존에 입력한 값("+49")과 다르므로 정수 프로퍼티가 될 수 없습니다.
alert( String(Math.trunc(Number("1.2"))) ); // "1"이 출력됩니다. 기존에 입력한 값("1.2")과 다르므로 정수 프로퍼티가 될 수 없습니다.
```
````

키가 정수가 아닌 경우엔 작성된 순서대로 프로퍼티가 나열됩니다. 예시를 살펴봅시다.

```js run
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // 프로퍼티를 하나 추가합니다.

*!*
// 정수 프로퍼티가 아닌 프로퍼티는 작성된 순서대로 나열됩니다.
*/!*
for (let prop in user) {
  alert( prop ); // name, surname, age
}
```

위 예시에서 49(독일 나라 번호)를 가장 위에 출력되도록 하려면 나라 번호가 정수로 취급되지 않도록 속임수를 쓰면 됩니다. 각 나라 번호 앞에 `"+"`를 붙여봅시다.

아래 같이 말이죠.

```js run
let codes = {
  "+49": "독일",
  "+41": "스위스",
  "+44": "영국",
  // ..,
  "+1": "미국"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
```

이제 원하는 대로 독일 나라 번호가 가장 먼저 출력되는 것을 확인할 수 있습니다.

## 참조에 의한 복사

객체와 원시 타입의 근본적인 차이 중 하나는 객체는 "참조에 의해(by reference)" 저장되고 복사된다는 것입니다.

원시값(문자열, 숫자, 불린 값)은 "값 그대로" 저장/할당되고 복사되는 반면에 말이죠.

예시:

```js
let message = "Hello!";
let phrase = message;
```

두 개의 독립된 변수를 만들고, 각 변수에 `"Hello!"`라는 문자열을 저장해보았습니다.

![](variable-copy-value.svg)

그런데 변수에 객체를 저장할 때는 다른 방식이 적용됩니다.

**변수에 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 "메모리 주소"인 객체에 대한 "참조 값"이 저장됩니다.**

그림을 통해 변수 user에 객체를 할당할 때 무슨 일이 일어나는지 이해해봅시다.

```js
let user = {
  name: "John"
};
```

![](variable-contains-reference.svg)

객체는 메모리 내 어딘가에 저장될 겁니다. 그리고 변수 `user`엔 객체에 대한 "참조 값"이 저장됩니다.

**객체가 할당된 변수를 복사할 땐 객체의 참조 값이 복사됩니다. 객체는 복제되지 않습니다.**

객체를 서랍장에 비유했을 때, 변수는 서랍장을 열 수 있는 열쇠라고 비유할 수 있습니다. 변수를 복사하면 똑같은 서랍장이 하나 더 만들어 지는 게 아니라 똑같은 열쇠가 하나 더 만들어집니다.

예시:

```js no-beautify
let user = { name: "John" };

let admin = user; // 참조값이 복사된 후, 변수에 할당됩니다.
```

이제 변수가 두 개가 되었고 각 변수엔 동일 객체에 대한 참조 값이 저장되었습니다.

![](variable-copy-reference.svg)

서랍장을 열 수 있는 열쇠(변수)가 두 개가 되었으므로 서랍장 안 내용물을 확인하거나 변경할 때 어느 변수를 사용해도 무방합니다.

```js run
let user = { name: 'John' };

let admin = user;

*!*
admin.name = 'Pete'; // "admin" 참조 값에 의해 변경됨
*/!*

alert(*!*user.name*/!*); // 'Pete'가 출력됨. "user" 참조 값을 이용해 변경사항을 확인함
```

위 예시에서 서랍장을 열 수 있는 키 두 개 중 하나(`admin`)를 사용해서 서랍장 안 내용물을 변경해보았고, 다른 키(`user`)를 사용해서 변경사항을 확인해 보았습니다. 이를 통해 객체는 오직 하나만 존재한다는 사실을 확인해 보았습니다. 

### 참조에 의한 비교

동등 연산자 `==`를 사용해 객체끼리 비교하는 것과 일치 연산자 `===`를 사용해 객체끼리 비교하는 것은 결과가 같습니다.

**일치 및 동등 비교 연산 시 두 객체가 동일한 객체인 경우에만 참이 반환됩니다.**

두 변수가 같은 객체를 참조하는 경우, 이 두 변수를 일치/동등 비교하면 참이 반환됩니다.

```js run
let a = {};
let b = a; // 참조에 의한 복사

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true
```

다른 예시를 살펴봅시다. 두 객체 모두 비어있다는 점에서 같아 보이지만, 두 객체를 일치/동등 비교하면 거짓이 반환됩니다.

```js run
let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
```

`obj1 > obj2` 같은 대소 비교나 `obj == 5` 같은 원시값과의 비교에선 객체가 원시형으로 변환됩니다. 객체가 어떻게 원시형으로 변하는지에 대해선 곧 학습할 것입니다. 다만 이러한 비교(객체끼리의 대소 비교나 원시값과 객체를 비교하는 것)가 필요한 경우는 매우 드뭅니다. 대게 실수 때문에 이런 비교가 이뤄집니다.

### Const 객체

`const`로 선언된 객체는 *변경이 가능*합니다.

예시:

```js run
const user = {
  name: "John"
};

*!*
user.age = 25; // (*)
*/!*

alert(user.age); // 25
```

많은 분이 `(*)`로 표시한 줄에서 에러가 날 것이라고 예상하셨을 겁니다. 하지만 에러는 발생하지 않습니다. 에러가 발생하지 않는 이유는 `const`는 오직 `user`에 저장된 값(한 객체에 대한 참조 값)만 고정하기 때문입니다. `user`는 한 객체에 대한 참조 값만 저장하고 있기 때문에 `(*)`로 표시한 줄에선 객체 *내부*에 접근하기만 하고 `user`를 재정의하지 않습니다.

`const`는 `user`를 다른 것으로 덮어씌우려 할 때 에러를 발생시킵니다. 예시를 보시죠.

```js run
const user = {
  name: "John"
};

*!*
// Error: Assignment to constant variable. (user를 재할당할 수 없습니다.)
*/!*
user = {
  name: "Pete"
};
```

그런데 객체 프로퍼티를 변경할 수 없게 하려면 어떻게 해야 할까요? `user.age = 25`에서 에러가 발생하게 하려면 말이죠. 이에 대한 내용은 <info:property-descriptors> 챕터에서 다루도록 하겠습니다.

## 복사와 병합, Object.assign

객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어진다는 걸 배웠습니다.

그런데 객체를 복제하고 싶다면 어떻게 해야 할까요? 기존에 있던 객체와 똑같으면서 독립적인 객체를 만들고 싶다면 말이죠.

방법은 있는데 자바스크립트 내장 메서드 중엔 객체를 복제해주는 메서드는 없기 때문에 조금 어렵습니다. 사실 객체를 복제해야 할 일은 거의 없습니다. 참조에 의한 복사로 해결 가능한 일이 대다수이죠.

그러나 정말 복제가 필요한 상황이라면 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 기존 객체를 복제할 수 있습니다.

아래와 같이 말이죠.

```js run
let user = {
  name: "John",
  age: 30
};

*!*
let clone = {}; // 새로운 빈 객체

// 빈 객체에 모든 user 프로퍼티를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}
*/!*

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

[Object.assign](mdn:js/Object/assign)를 사용해 객체를 복제하는 방법도 있습니다.

Object.assign은 다음과 같이 사용합니다.

```js
Object.assign(dest, [src1, src2, src3...])
```

- 인수 `dest` 와 `src1, ..., srcN` 는 객체입니다. `...`은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있다는 것을 나타냅니다.
- 객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사합니다. 두 번째 인수부터 모든 객체의 프로퍼티가 첫 번째 인수 객체로 복사됩니다. 그리고 `dest`를 반환합니다.

여러 객체를 하나로 병합할 때 assign 메서드를 사용할 수 있습니다.
```js
let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

*!*
// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);
*/!*

// user = { name: "John", canView: true, canEdit: true }
```

복사된 프로퍼티를 받는 객체(`user`)에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값을 덮어씁니다.

```js
let user = { name: "John" };

// name을 덮어쓰고 isAdmin을 추가합니다.
Object.assign(user, { name: "Pete", isAdmin: true });

// user = { name: "Pete", isAdmin: true }
```

반복문 대신 `Object.assign`을 사용하면 간단히 객체를 복사할 할 수도 있습니다.

```js
let user = {
  name: "John",
  age: 30
};

*!*
let clone = Object.assign({}, user);
*/!*
```

이 코드는 `user`의 모든 프로퍼티를 빈 객체에 복사한 뒤 새롭게 갱신된 객체를 반환해줍니다. 반복문을 사용한 것과 결과는 동일한데 코드가 더 짧아졌네요.

지금까진 `user`의 모든 프로퍼티가 원시값인 경우만 가정했습니다. 그런데 프로퍼티는 다른 객체에 대한 참조 값일 수도 있습니다. 이 경우는 어떻게 해야 할까요?

아래와 같이 말이죠.
```js run
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
```

`clone.sizes = user.sizes`로 프로퍼티를 복사하는 것만으론 객체를 복제할 수 없습니다. `user.sizes`는 객체이기 때문에 참조 값이 복사되기 때문입니다. `clone.sizes = user.sizes`로 프로퍼티를 복사하면 `clone`과 `user`는 같은 sizes를 공유하게 됩니다.

아래와 같이 말이죠.
```js run
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체입니다.

// user와 clone는 sizes를 공유합니다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경합니다.
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다.
```

이 문제를 해결하려면 `user[key]`의 각 값을 검사하면서 그 값이 객체라면 객체의 구조도 복사해주는 반복문을 사용해야 합니다. 이를 "깊은 복사(deep cloning)"라고 부릅니다.

깊은 복사 시 사용되는 표준 알고리즘, [Structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)을 사용하면 위 사례를 비롯한 다양한 상황에서 객체를 복제할 수 있습니다. 자바스크립트 라이브러리 [lodash](https://lodash.com)의 메서드, [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 이 알고리즘을 직접 구현하지 않고도 깊은 복사를 처리할 수 있으므로 참고하시기 바랍니다.



## 요약

객체는 몇 가지 특수한 기능을 가진 연관 배열(associative array)입니다.

객체는 프로퍼티(키-값 쌍)를 저장합니다.
- 프로퍼티 키는 문자열이나 심볼(Symbol)이어야 합니다. 보통 문자열을 사용합니다.
- 값은 어떤 자료형도 가능합니다.

아래와 같은 방법을 사용하면 프로퍼티에 접근할 수 있습니다.
- 점 표기법: `obj.property`
- 대괄호 표기법 `obj["property"]`. 대괄호 표기법을 사용하면 `obj[varWithKey]`같이 변수에서 키를 가져올 수 있습니다.

객체엔 다음과 같은 추가 연산자를 사용할 수 있습니다.
- 프로퍼티를 삭제하고 싶을 때: `delete obj.prop`
- 해당 key를 가진 프로퍼티가 객체 내에 있는지 확인하고자 할 때: `"key" in obj`
- 프로퍼티를 나열할 때: `for (let key in obj)`

객체는 참조에 의해 할당되고 복사됩니다. 변수엔 "객체" 자체가 아닌 메모리상의 주소인 "참조"가 저장됩니다. 객체가 할당된 변수를 복사하거나 함수의 인자로 넘길 때 객체가 아닌 객체의 참조가 전달되죠. 복사된 참조를 이용한 모든 작업(프로퍼티 추가/삭제 등)은 동일한 객체를 대상으로 이뤄집니다.

객체를 복제하려면 `Object.assign`이나  [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)를 사용하면 됩니다.

지금까진 "순수 객체(plain object)"라 불리는 일반 `객체(Object)`에 대해 학습했습니다.

자바스크립트에는 일반 객체 이외에도 다양한 종류의 객체가 있습니다.

- `Array` -- 정렬된 데이터 컬렉션을 저장할 때 쓰임
- `Date` -- 날짜와 시간 정보를 저장할 때 쓰임 
- `Error` -- 에러 정보를 저장할 때 쓰임 
- 기타 등등

각 객체마다 고유의 기능을 제공하는데, 이에 대해선 추후 학습해 보도록 하겠습니다. 사람들은 종종 "Array 타입"이나 "Date 타입"이라는 용어를 쓸 때가 있습니다. 사실 Array와 Date는 독립적인 자료형이 아니라 "객체"형에 속합니다. 객체에 다양한 기능을 넣어 확장한 또 다른 객체이죠.

객체는 다재다능한 자료구조로, 자바스크립트에서 그 영향력이 막강합니다. 지금까진 객체라는 거대한 주제의 극히 일부만 다루었습니다. 튜토리얼 뒤쪽에서 객체에 대한 더 상세한 내용을 다루도록 하겠습니다.
